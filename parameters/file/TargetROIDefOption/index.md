---   
layout: default-layout
title:  TargetROIDef Object Introduction
description: Introduced the TargetROIDef definition for Dynamsoft Capture Vision.
keywords: TargetROIDef
needAutoGenerateSidebar: true
noTitleIndex: true
---

# The Design of TargetROIDef Object

The `TargetROIDef` object is used to specify one or more recognition tasks to be performed on some regions of interest (ROIs) within an image. In order to clarify the concept, we first define a few concept nouns：

- **Atomic result object**: Represents the atomic result of the recognition task output. It can be a color detection region, a barcode, a text line, a table cell, etc.
- **Reference region**：It includes two types: full image region and atomic result region. The former refers to the reference area formed by the original image, and the latter refers to the reference area formed by each atomic result object.
- **Target region**：The target region is calculated based on the reference region and offsets.

The diagram illustrates a scenario where we aim to read the text above a barcode. From the diagram, we can observe the following:

- `T1`, `T2`, `T3` are three atomic objects of `TextLine` type, and B1 is one atomic object of `Barcode` type.
- `ROI1` and `ROI2` are two `TargetROIDef` objects, where `ROI1`'s reference region is the entire image area.
- `ROI2`'s reference region is the atomic result region generated by `ROI1`, with an upward offset configuration.
- The blue Quad region is one target region of `ROI2`.

<div align="center">
   <p><img src="../assets/roi-concept.png" alt="Basic concepts of TargetROIDef" width="100%" /></p>
   <p>Figure 1 – Basic concepts of TargetROIDef</p>
</div>

Using the recursive definition of the reference relationship between target region and reference region, a complex workflow can be constructed to meet the requirements of complex scenarios.

Next, we will further detail how this workflow is constructed.

## How It Builds Up the Workflow

### Construct a Dependency Graph

The following json is a parameter template fragment configured with ROI dependencies.

```json
{
    "TargetROIDefOptions" : [
        {
            "Name" : "roi_ddn", 
            "TaskSettingNameArray": [ "ddn_task" ], 
            "Location" : null
        }, 
        {
            "Name" : "roi_dlr", 
            "TaskSettingNameArray": [ "dlr_task" ], 
            "Location": 
            {
                "ReferenceObjectFilter" : {
                    "ReferenceTargetROIDefNameArray": ["roi_ddn"], 
                },
                "Offset": null
            }
        },
        {
            "Name" : "roi_dbr1", 
            "TaskSettingNameArray": [ "dbr_task" ], 
            "Location": 
            {
                "ReferenceObjectFilter" : {
                    "ReferenceTargetROIDefNameArray": ["roi_dlr"], 
                },
                "Offset":{
                    // offset downwards
                }
            }
        },
        {
            "Name" : "roi_dbr2", 
            "TaskSettingNameArray": [ "dbr_task" ], 
            "Location": 
            {
                "ReferenceObjectFilter" : {
                    "ReferenceTargetROIDefNameArray": ["roi_dlr"], 
                },
                "Offset":{
                    // offset upwards
                }
            }
        }
    ]
}
```

<div align="center">
   <p>Example 1 – TargetROIDef Parameters</p>
</div>

The following points can be found:

- It configures four `TargetROIDef` objects: `ddn_roi`, `dlr_roi`, `dbr_roi1`, and `dbr_roi2`.
- `dlr_roi` is configured to depend on `ddn_roi` and has a `null` offset, which means it uses the same region as the output region of `ddn_roi`.
- `dbr_roi1` is configured to depend on `dlr_roi` and has an offset configured to be shifted downwards from the output region of `dlr_roi`.
- `dbr_roi2` is also configured to depend on `dlr_roi` and has an offset configured to be shifted upwards from the output region of `dlr_roi`.

When DCV parses the `TargetROIDef` object in the parameter template, it constructs a directed dependency graph based on the configured dependencies between different `TargetROIDef` objects. During actual execution, the tasks are executed in the order specified by the dependency graph. The following figure illustrates the generated dependency graph after parsing the above template fragment.

<div align="center">
   <p><img src="../assets/dependency-graph.png" alt="Basic concepts of TargetROIDef" width="70%" /></p>
   <p>Figure 2 – Dependency Graph</p>
</div>

### Filter Out the Desired Reference Objects

In practical applications, if a `TargetROIDef` object named `roi2`, depends on another `TargetROIDef` object named `roi1`, it may not want to depend unconditionally on all the region results generated by `roi1`. Instead, it may want to depend only on those region results that meet certain filtering conditions, such as the text meeting a specific regular expression or the barcode type meeting specific formatting requirements.

In the following JSON snippet, based on `Example 1`, regular expression filtering conditions are added to `dbr_roi1` and `dbr_roi2`:

```json
{
    "TargetROIDefOptions" : [
        //......
        {
            "Name" : "roi_dbr1", 
            //......
            "Location": 
            {
                "ReferenceObjectFilter" : {
                    "ReferenceTargetROIDefNameArray": ["roi_dlr"], 
                    "TextLineFilteringCondition":
                    {
                        "LineStringRegExPattern": "^P/N" 
                    }
                },
                //......
            }
        },
        {
            "Name" : "roi_dbr2", 
            //......
            "Location": 
            {
                "ReferenceObjectFilter" : {
                    "ReferenceTargetROIDefNameArray": ["roi_dlr"], 
                    "TextLineFilteringCondition":
                    {
                        "LineStringRegExPattern": "^L/N" 
                    }
                },
                //......
            }
        }
    ]
}
```

It can be seen that:

- `roi_dbr1` is configured to only depend on the region results generated by `roi_dlr` that meet the regular expression "^P/N".
- `roi_dbr2` is configured to only depend on the region results generated by `roi_dlr` that meet the regular expression "^L/N".

At runtime, region results that do not meet the filtering conditions will be discarded and will not be passed as inputs to subsequent `TargetROIDef` for further processing.
